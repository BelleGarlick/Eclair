<!DOCTYPE html>
<html>
<head>
<title>Page Title</title>
<script src="eclair.js"></script>
</head>
<body>

<style>
    .code::-webkit-scrollbar {
        display: none;
    }
    
    .code {
        -ms-overflow-style: none; 
        scrollbar-width: none; 
    }
</style>
    
<script>
    
let sharedStyle = eclair.Style()
    .position("relative")
    .width("420px")
    .height("360px")
    .borderSize("1px")
    .borderStyle("solid")
    .borderColor("#999999")
    .borderRadius("3px")

let textAreaChild = eclair.Style()
    .position("absolute")
    .top("0px")
    .left("0px")
    .width("100%")
    .height("100%")
    .fontSize("14px")
    .font("monospace")
    .borderSize("0px")
    .outline("none")
    .caretColor("black")
    .resize("none")
    .whiteSpace("pre")
    .boxSizing("border-box")
    .padding("10px")
    .overflowWrap("normal")
    .overflowX("scroll")


let syntaxHighlighterColors = {
    "comment": "grey",
    "keyword": "#0066ee",
    "eclair": "#009900",
    "string": "#dd9900",
    "quote": "#dd9900"
}
    
class SyntaxHighlighter extends EclairComponent {
    constructor() {
        super()
        let highlighterRules = {
            "seperators": [
                "{", "(", " ", "}", ")", "[", "]", "\n", "\t", "."
            ],
            "special": [
                "VStack", "HStack", "State", "Toggle", "Text", "HorizontalLine", "Alignment", "eclair", "Ø"
            ],
            "keywords": [
                "let", "var", "if", "else", "true", "false", "const", "for", "while", "await", "break", "case", "catch", "class", "continue", "debugger", "default", "delete", 
                "do", "enum", "export", "extends", "finally", "function", "implements", "import", 
                "in", "instanceof", "interface", "new", "null", "package", "private", "protected", 
                "public", "return", "super", "switch", "static", "this", "throw", "try", "typeof",
                "void", "while", "with", "yield"
            ]
        }
        
        this.tokenSeperators = new Set(highlighterRules["seperators"])
        this.eclairKeywords = new Set(highlighterRules["special"])
        this.jsKeywords = new Set(highlighterRules["keywords"])
         	 	 	 
        this.theme = syntaxHighlighterColors;
        
        this.cachedLines = {}
        
        this.addStyle(sharedStyle)
        
        this.codeState = Ø(`// Example Toggle Code
let toggleOn = Ø(true)
let toggleTick = Ø(false)
let toggleEnabled = Ø(true)

// Create layout
eclair.VStack([
    // Attach states to toggle
    eclair.VStack([
        eclair.Toggle(toggleOn)
            .showTick(toggleTick)
            .enabled(toggleEnabled)
    ]).width("100%"),

    eclair.HorizontalLine(),

    // Tick mark toggle
    eclair.Text("Tick Mark"),
    eclair.Toggle(toggleTick),

    // Toggle toggle
    eclair.Text("'Toggle'"),
    eclair.Toggle(true)
        .onChange(e => {
		toggleOn.toggle()
	}),

    // Toggle enabled
    eclair.Text("Enabled"),
    eclair.Toggle(toggleEnabled)
])
    .alignment(eclair.Alignment().start())
    .gap("8px")
    .write()`)
        
        this.codeElement = eclair.CustomTagComponent("code")
            .addStyle("child")
            .addStyle("code")
            .addStyle(textAreaChild)
        this.textArea = eclair.TextArea(this.codeState)
            .onScroll((e, ev) => {
                let textarea = e.getElement()
                this.codeElement.getElement().scroll(textarea.scrollLeft, textarea.scrollTop)
            })
            .onInput(_ => {
                this.update()
            })
            .addStyle(textAreaChild)
            .addStyle("child")
            .setAttr("style", "background: transparent; color: rgb(1, 1, 1, 0); box-sizing: border-box")
            .setAttr("spellcheck", "false")
            
    
    }
    
    update() {
        let code = this.codeState.value();
        
        

        let output = "";
        let tokenisedLines = []

        let lines = code.split("\n")
        let allLines = new Set(lines)
        for (let l = 0; l < lines.length; l++) {
            if (!this.cachedLines.hasOwnProperty(lines[l])) {
                this.cachedLines[lines[l]] = this.tokeniseLine(lines[l])
            }
            tokenisedLines.push(this.cachedLines[lines[l]])
        }
        
        let cachedKeys = Object.keys(this.cachedLines)
        for (let i = 0; i < cachedKeys.length; i++) {
            if (!allLines.has(cachedKeys[i])) {
                delete this.cachedLines[cachedKeys[i]]
            }
        }


        let formattedCode = ""
        for (let l = 0; l < tokenisedLines.length; l++) {
            let cline = tokenisedLines[l];
            for (let t = 0; t < cline.length; t++) {
                formattedCode += "<span style='color:"+this.theme[cline[t].type]+"'>" + cline[t].text + "</span>"
            }
            formattedCode += "<br/>"
        }

        
        this.codeElement.innerHTML(`<pre style="margin: 0px; padding: 0px;">${formattedCode}</pre>`)
        
        return this
    }
    
    tokeniseLine(line) {
        let tokens = [], token = "", state = ""

        let self = this;
        function pushTokenState(_text, _state) {
            if (state == "") {
                if (self.jsKeywords.has(_text)) {_state = "keyword"}
                if (self.eclairKeywords.has(_text)) {_state = "eclair"}
            }

            tokens.push({"text": _text, "type": _state})
            state = "", token = ""
        }

        for (let c = 0; c < line.length; c++) {
            if (state == "comment") {token += line[c]} 

            else if (state != "comment" && c < line.length - 1 && line[c] == "/" && line[c + 1] == "/") {
                pushTokenState(token, state); state = "comment"; token = line[c]
            } 

            else if (state != "quote" && state != "string" && line[c] == "'") {
                pushTokenState(token, state)

                state = "quote"; token = line[c]
            } 

            // If state is quote and char in ' then end the token state.
            else if (state == "quote" && line[c] == "'") {pushTokenState(token + "'", state)} 

            // If state is string and char in " then end the token state.
            else if (state == "string" && line[c] == '"') {pushTokenState(token + '"', state)} 

            // If not a string or quote, and the " is this then end the current token and start a string
            else if (state != "string" && state != "quote" && line[c] == '"') {pushTokenState(token, state); state = "string"; token = line[c]} 

            else if (state != "string" && state != "quote" && this.tokenSeperators.has(line[c])) {
                pushTokenState(token, state)
                token = line[c]
            }

            else {
                if (this.tokenSeperators.has(token)) {
                    pushTokenState(token, state)
                }
                token += line[c]
            }
        }

        tokens.push({"text": token, "type": state})

        return tokens
    }
    
    build() {
        return `<div>${this.codeElement.compile()}${this.textArea.compile()}</div>`
    }
}
    
    
let highlighter = new SyntaxHighlighter()
    .write()


</script>

</body>
</html>

